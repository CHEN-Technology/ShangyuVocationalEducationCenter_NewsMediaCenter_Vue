import {
  __commonJS
} from "./chunk-MJ3GX4GI.js";

// node_modules/enlarge-file-upload/dist/upload.js
var require_upload = __commonJS({
  "node_modules/enlarge-file-upload/dist/upload.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.createUploader = t() : e.createUploader = t();
    }(exports, () => (() => {
      var e = { 425: (e2, t2, n2) => {
        function r(e3) {
          return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, r(e3);
        }
        function o(e3, t3) {
          return function(e4) {
            if (Array.isArray(e4)) return e4;
          }(e3) || function(e4, t4) {
            var n3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
            if (null != n3) {
              var r2, o2, s2, i2, a2 = [], c2 = true, u2 = false;
              try {
                if (s2 = (n3 = n3.call(e4)).next, 0 === t4) {
                  if (Object(n3) !== n3) return;
                  c2 = false;
                } else for (; !(c2 = (r2 = s2.call(n3)).done) && (a2.push(r2.value), a2.length !== t4); c2 = true) ;
              } catch (e5) {
                u2 = true, o2 = e5;
              } finally {
                try {
                  if (!c2 && null != n3.return && (i2 = n3.return(), Object(i2) !== i2)) return;
                } finally {
                  if (u2) throw o2;
                }
              }
              return a2;
            }
          }(e3, t3) || i(e3, t3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function s(e3, t3) {
          var n3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
          if (!n3) {
            if (Array.isArray(e3) || (n3 = i(e3)) || t3 && e3 && "number" == typeof e3.length) {
              n3 && (e3 = n3);
              var r2 = 0, o2 = function() {
              };
              return { s: o2, n: function() {
                return r2 >= e3.length ? { done: true } : { done: false, value: e3[r2++] };
              }, e: function(e4) {
                throw e4;
              }, f: o2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var s2, a2 = true, c2 = false;
          return { s: function() {
            n3 = n3.call(e3);
          }, n: function() {
            var e4 = n3.next();
            return a2 = e4.done, e4;
          }, e: function(e4) {
            c2 = true, s2 = e4;
          }, f: function() {
            try {
              a2 || null == n3.return || n3.return();
            } finally {
              if (c2) throw s2;
            }
          } };
        }
        function i(e3, t3) {
          if (e3) {
            if ("string" == typeof e3) return a(e3, t3);
            var n3 = {}.toString.call(e3).slice(8, -1);
            return "Object" === n3 && e3.constructor && (n3 = e3.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(e3) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? a(e3, t3) : void 0;
          }
        }
        function a(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var n3 = 0, r2 = Array(t3); n3 < t3; n3++) r2[n3] = e3[n3];
          return r2;
        }
        function c() {
          "use strict";
          c = function() {
            return t3;
          };
          var e3, t3 = {}, n3 = Object.prototype, o2 = n3.hasOwnProperty, s2 = Object.defineProperty || function(e4, t4, n4) {
            e4[t4] = n4.value;
          }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", u2 = i2.asyncIterator || "@@asyncIterator", l2 = i2.toStringTag || "@@toStringTag";
          function f2(e4, t4, n4) {
            return Object.defineProperty(e4, t4, { value: n4, enumerable: true, configurable: true, writable: true }), e4[t4];
          }
          try {
            f2({}, "");
          } catch (e4) {
            f2 = function(e5, t4, n4) {
              return e5[t4] = n4;
            };
          }
          function h(e4, t4, n4, r2) {
            var o3 = t4 && t4.prototype instanceof w ? t4 : w, i3 = Object.create(o3.prototype), a3 = new P(r2 || []);
            return s2(i3, "_invoke", { value: A(e4, n4, a3) }), i3;
          }
          function p(e4, t4, n4) {
            try {
              return { type: "normal", arg: e4.call(t4, n4) };
            } catch (e5) {
              return { type: "throw", arg: e5 };
            }
          }
          t3.wrap = h;
          var d = "suspendedStart", m = "suspendedYield", y = "executing", g = "completed", b = {};
          function w() {
          }
          function v() {
          }
          function E() {
          }
          var S = {};
          f2(S, a2, function() {
            return this;
          });
          var x = Object.getPrototypeOf, O = x && x(x(N([])));
          O && O !== n3 && o2.call(O, a2) && (S = O);
          var R = E.prototype = w.prototype = Object.create(S);
          function k(e4) {
            ["next", "throw", "return"].forEach(function(t4) {
              f2(e4, t4, function(e5) {
                return this._invoke(t4, e5);
              });
            });
          }
          function T(e4, t4) {
            function n4(s3, i4, a3, c2) {
              var u3 = p(e4[s3], e4, i4);
              if ("throw" !== u3.type) {
                var l3 = u3.arg, f3 = l3.value;
                return f3 && "object" == r(f3) && o2.call(f3, "__await") ? t4.resolve(f3.__await).then(function(e5) {
                  n4("next", e5, a3, c2);
                }, function(e5) {
                  n4("throw", e5, a3, c2);
                }) : t4.resolve(f3).then(function(e5) {
                  l3.value = e5, a3(l3);
                }, function(e5) {
                  return n4("throw", e5, a3, c2);
                });
              }
              c2(u3.arg);
            }
            var i3;
            s2(this, "_invoke", { value: function(e5, r2) {
              function o3() {
                return new t4(function(t5, o4) {
                  n4(e5, r2, t5, o4);
                });
              }
              return i3 = i3 ? i3.then(o3, o3) : o3();
            } });
          }
          function A(t4, n4, r2) {
            var o3 = d;
            return function(s3, i3) {
              if (o3 === y) throw Error("Generator is already running");
              if (o3 === g) {
                if ("throw" === s3) throw i3;
                return { value: e3, done: true };
              }
              for (r2.method = s3, r2.arg = i3; ; ) {
                var a3 = r2.delegate;
                if (a3) {
                  var c2 = j(a3, r2);
                  if (c2) {
                    if (c2 === b) continue;
                    return c2;
                  }
                }
                if ("next" === r2.method) r2.sent = r2._sent = r2.arg;
                else if ("throw" === r2.method) {
                  if (o3 === d) throw o3 = g, r2.arg;
                  r2.dispatchException(r2.arg);
                } else "return" === r2.method && r2.abrupt("return", r2.arg);
                o3 = y;
                var u3 = p(t4, n4, r2);
                if ("normal" === u3.type) {
                  if (o3 = r2.done ? g : m, u3.arg === b) continue;
                  return { value: u3.arg, done: r2.done };
                }
                "throw" === u3.type && (o3 = g, r2.method = "throw", r2.arg = u3.arg);
              }
            };
          }
          function j(t4, n4) {
            var r2 = n4.method, o3 = t4.iterator[r2];
            if (o3 === e3) return n4.delegate = null, "throw" === r2 && t4.iterator.return && (n4.method = "return", n4.arg = e3, j(t4, n4), "throw" === n4.method) || "return" !== r2 && (n4.method = "throw", n4.arg = new TypeError("The iterator does not provide a '" + r2 + "' method")), b;
            var s3 = p(o3, t4.iterator, n4.arg);
            if ("throw" === s3.type) return n4.method = "throw", n4.arg = s3.arg, n4.delegate = null, b;
            var i3 = s3.arg;
            return i3 ? i3.done ? (n4[t4.resultName] = i3.value, n4.next = t4.nextLoc, "return" !== n4.method && (n4.method = "next", n4.arg = e3), n4.delegate = null, b) : i3 : (n4.method = "throw", n4.arg = new TypeError("iterator result is not an object"), n4.delegate = null, b);
          }
          function C(e4) {
            var t4 = { tryLoc: e4[0] };
            1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
          }
          function L(e4) {
            var t4 = e4.completion || {};
            t4.type = "normal", delete t4.arg, e4.completion = t4;
          }
          function P(e4) {
            this.tryEntries = [{ tryLoc: "root" }], e4.forEach(C, this), this.reset(true);
          }
          function N(t4) {
            if (t4 || "" === t4) {
              var n4 = t4[a2];
              if (n4) return n4.call(t4);
              if ("function" == typeof t4.next) return t4;
              if (!isNaN(t4.length)) {
                var s3 = -1, i3 = function n5() {
                  for (; ++s3 < t4.length; ) if (o2.call(t4, s3)) return n5.value = t4[s3], n5.done = false, n5;
                  return n5.value = e3, n5.done = true, n5;
                };
                return i3.next = i3;
              }
            }
            throw new TypeError(r(t4) + " is not iterable");
          }
          return v.prototype = E, s2(R, "constructor", { value: E, configurable: true }), s2(E, "constructor", { value: v, configurable: true }), v.displayName = f2(E, l2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
            var t4 = "function" == typeof e4 && e4.constructor;
            return !!t4 && (t4 === v || "GeneratorFunction" === (t4.displayName || t4.name));
          }, t3.mark = function(e4) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e4, E) : (e4.__proto__ = E, f2(e4, l2, "GeneratorFunction")), e4.prototype = Object.create(R), e4;
          }, t3.awrap = function(e4) {
            return { __await: e4 };
          }, k(T.prototype), f2(T.prototype, u2, function() {
            return this;
          }), t3.AsyncIterator = T, t3.async = function(e4, n4, r2, o3, s3) {
            void 0 === s3 && (s3 = Promise);
            var i3 = new T(h(e4, n4, r2, o3), s3);
            return t3.isGeneratorFunction(n4) ? i3 : i3.next().then(function(e5) {
              return e5.done ? e5.value : i3.next();
            });
          }, k(R), f2(R, l2, "Generator"), f2(R, a2, function() {
            return this;
          }), f2(R, "toString", function() {
            return "[object Generator]";
          }), t3.keys = function(e4) {
            var t4 = Object(e4), n4 = [];
            for (var r2 in t4) n4.push(r2);
            return n4.reverse(), function e5() {
              for (; n4.length; ) {
                var r3 = n4.pop();
                if (r3 in t4) return e5.value = r3, e5.done = false, e5;
              }
              return e5.done = true, e5;
            };
          }, t3.values = N, P.prototype = { constructor: P, reset: function(t4) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(L), !t4) for (var n4 in this) "t" === n4.charAt(0) && o2.call(this, n4) && !isNaN(+n4.slice(1)) && (this[n4] = e3);
          }, stop: function() {
            this.done = true;
            var e4 = this.tryEntries[0].completion;
            if ("throw" === e4.type) throw e4.arg;
            return this.rval;
          }, dispatchException: function(t4) {
            if (this.done) throw t4;
            var n4 = this;
            function r2(r3, o3) {
              return a3.type = "throw", a3.arg = t4, n4.next = r3, o3 && (n4.method = "next", n4.arg = e3), !!o3;
            }
            for (var s3 = this.tryEntries.length - 1; s3 >= 0; --s3) {
              var i3 = this.tryEntries[s3], a3 = i3.completion;
              if ("root" === i3.tryLoc) return r2("end");
              if (i3.tryLoc <= this.prev) {
                var c2 = o2.call(i3, "catchLoc"), u3 = o2.call(i3, "finallyLoc");
                if (c2 && u3) {
                  if (this.prev < i3.catchLoc) return r2(i3.catchLoc, true);
                  if (this.prev < i3.finallyLoc) return r2(i3.finallyLoc);
                } else if (c2) {
                  if (this.prev < i3.catchLoc) return r2(i3.catchLoc, true);
                } else {
                  if (!u3) throw Error("try statement without catch or finally");
                  if (this.prev < i3.finallyLoc) return r2(i3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e4, t4) {
            for (var n4 = this.tryEntries.length - 1; n4 >= 0; --n4) {
              var r2 = this.tryEntries[n4];
              if (r2.tryLoc <= this.prev && o2.call(r2, "finallyLoc") && this.prev < r2.finallyLoc) {
                var s3 = r2;
                break;
              }
            }
            s3 && ("break" === e4 || "continue" === e4) && s3.tryLoc <= t4 && t4 <= s3.finallyLoc && (s3 = null);
            var i3 = s3 ? s3.completion : {};
            return i3.type = e4, i3.arg = t4, s3 ? (this.method = "next", this.next = s3.finallyLoc, b) : this.complete(i3);
          }, complete: function(e4, t4) {
            if ("throw" === e4.type) throw e4.arg;
            return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), b;
          }, finish: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var n4 = this.tryEntries[t4];
              if (n4.finallyLoc === e4) return this.complete(n4.completion, n4.afterLoc), L(n4), b;
            }
          }, catch: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var n4 = this.tryEntries[t4];
              if (n4.tryLoc === e4) {
                var r2 = n4.completion;
                if ("throw" === r2.type) {
                  var o3 = r2.arg;
                  L(n4);
                }
                return o3;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(t4, n4, r2) {
            return this.delegate = { iterator: N(t4), resultName: n4, nextLoc: r2 }, "next" === this.method && (this.arg = e3), b;
          } }, t3;
        }
        function u(e3, t3, n3, r2, o2, s2, i2) {
          try {
            var a2 = e3[s2](i2), c2 = a2.value;
          } catch (e4) {
            return void n3(e4);
          }
          a2.done ? t3(c2) : Promise.resolve(c2).then(r2, o2);
        }
        function l(e3) {
          return function() {
            var t3 = this, n3 = arguments;
            return new Promise(function(r2, o2) {
              var s2 = e3.apply(t3, n3);
              function i2(e4) {
                u(s2, r2, o2, i2, a2, "next", e4);
              }
              function a2(e4) {
                u(s2, r2, o2, i2, a2, "throw", e4);
              }
              i2(void 0);
            });
          };
        }
        var f = n2(806);
        e2.exports = function(e3) {
          var t3;
          if (!e3.uploadFunction) throw new Error("The required parameter uploadFunction is missing");
          var n3 = (null === (t3 = navigator) || void 0 === t3 ? void 0 : t3.hardwareConcurrency) || 0;
          n3 = n3 ? Math.max(n3 - 2, 1) : 1;
          var r2 = [], u2 = null, h = 0, p = false, d = [], m = [], y = 0, g = 0, b = [], w = 0, v = null, E = null, S = 0, x = 0, O = e3.threads || n3, R = false, k = new Proxy({ progress: 0, speed: 0, uploadEnd: false, hash: "", file: "", totalChunks: "", errorMsg: "", allChunks: [], hashMap: /* @__PURE__ */ new Map() }, { set: function(e4, t4, n4) {
            return "progress" === t4 || "speed" === t4 ? (e4[t4] = n4, true) : "uploadEnd" === t4 ? (e4[t4] = true, true) : ("hash" === t4 || "file" === t4 || "totalChunks" === t4 || "errorMsg" === t4 || "allChunks" === t4 || "hashMap" === t4) && (e4[t4] = n4, true);
          } });
          function T(e4) {
            for (var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5242880, n4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r3 = [], o2 = Math.ceil((e4.size - n4) / t4), s2 = 0; s2 < o2; s2++) {
              var i2 = e4.slice(n4 + t4 * s2, n4 + t4 * (s2 + 1));
              r3.push(i2);
            }
            return k.allChunks = r3, r3;
          }
          function A(e4) {
            return j.apply(this, arguments);
          }
          function j() {
            return j = l(c().mark(function e4(t4) {
              var n4, r3 = arguments;
              return c().wrap(function(e5) {
                for (; ; ) switch (e5.prev = e5.next) {
                  case 0:
                    return n4 = r3.length > 1 && void 0 !== r3[1] ? r3[1] : 4, e5.abrupt("return", new Promise(function(e6) {
                      n4 = Math.min(n4, t4.length);
                      for (var r4 = Math.ceil(t4.length / n4), i2 = 0, a2 = /* @__PURE__ */ new Map(), c2 = 0; c2 < n4; c2++) {
                        var u3 = new Worker(URL.createObjectURL(new Blob(["\n                if(typeof CryptoJS === 'undefined'){\n                    importScripts('https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js');\n                }\n                self.onmessage = async (e) => {\n                  const { slices, startIndex } = e.data;\n                  const hashes = new Map();\n  \n                  for (let i = 0; i < slices.length; i++) {\n                    const blob = slices[i];\n                    try {\n                      // 转换 Blob → ArrayBuffer → Uint8Array\n                      const arrayBuffer = await blob.arrayBuffer();\n                      const chunk = new Uint8Array(arrayBuffer);\n  \n                    // 计算哈希\n                    const wordArray = CryptoJS.lib.WordArray.create(chunk);\n                    const hashHex = CryptoJS.SHA256(wordArray).toString();\n                      hashes.set(startIndex + i, hashHex);\n                    } catch (error) {\n                      console.error('Error processing chunk:', error);\n                      hashes.set(startIndex + i, 'error');\n                    }\n                  }\n  \n                  // 将 Map 转换为可序列化的数组\n                  const serializableResults = Array.from(hashes.entries());\n                  self.postMessage({ results: serializableResults });\n                  self.close();\n                };"], { type: "text/javascript" }))), l2 = c2 * r4, f2 = Math.min(l2 + r4, t4.length);
                        u3.postMessage({ slices: t4.slice(l2, f2), startIndex: l2 }), u3.onmessage = function(t5) {
                          var r5, c3 = s(t5.data.results);
                          try {
                            for (c3.s(); !(r5 = c3.n()).done; ) {
                              var u4 = o(r5.value, 2), l3 = u4[0], f3 = u4[1];
                              a2.set(l3, f3);
                            }
                          } catch (e7) {
                            c3.e(e7);
                          } finally {
                            c3.f();
                          }
                          ++i2 === n4 && e6(a2);
                        };
                      }
                    }));
                  case 2:
                  case "end":
                    return e5.stop();
                }
              }, e4);
            })), j.apply(this, arguments);
          }
          function C(e4) {
            return L.apply(this, arguments);
          }
          function L() {
            return (L = l(c().mark(function t4(n4) {
              return c().wrap(function(t5) {
                for (; ; ) switch (t5.prev = t5.next) {
                  case 0:
                    if (true === e3.hash) {
                      t5.next = 3;
                      break;
                    }
                    return k.hash = null, t5.abrupt("return");
                  case 3:
                    return t5.abrupt("return", new Promise(function(t6, r3) {
                      var o2 = URL.createObjectURL(new Blob(["\n                  importScripts('https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js');\n                  \n                  self.onmessage = async function (event) {\n                      const { chunks, hashNumFlag, chunkMap={}} = event.data;\n                      let hashValue = CryptoJS.lib.WordArray.create(); // 使用 WordArray 来存储哈希\n                      const hashes = new Map();\n                      let index = 0\n\n                      const updateHash = (chunk) => {\n                          return new Promise(async (resolve) => {\n                              const chunkBuffer = await chunk.arrayBuffer();\n                              const wordArray = CryptoJS.lib.WordArray.create(chunkBuffer);\n                              const chunkHash = CryptoJS.SHA256(wordArray); \n                              hashValue = CryptoJS.SHA256(hashValue.concat(chunkHash)); \n                              if(hashNumFlag){\n                                if(chunkMap === true || chunkMap?.enable){\n                                    const chunkHashString = chunkHash.toString();\n                                    hashes.set(index, chunkHashString);\n                                }\n                              }\n                              resolve();\n                          });\n                      };\n\n                      for (const chunk of chunks) {\n                        index++\n                          await updateHash(chunk);\n                      }\n\n                      const finalHash = hashValue.toString(); // 计算得到的最终哈希\n                      self.postMessage({finalHash,hashes});\n                      self.close();\n                  };\n              "], { type: "application/javascript" })), s2 = new Worker(o2);
                      s2.postMessage({ chunks: n4, hashNumFlag: R, chunkMap: e3.chunkMap }), s2.onmessage = function(e4) {
                        var n5;
                        k.hash = e4.data.finalHash, (null === (n5 = e4.data.hashes) || void 0 === n5 ? void 0 : n5.size) > 0 && (k.hashMap = e4.data.hashes), t6(e4.data.finalHash), URL.revokeObjectURL(o2);
                      }, s2.onerror = function(e4) {
                        k.hash = e4, URL.revokeObjectURL(o2);
                      };
                    }));
                  case 4:
                  case "end":
                    return t5.stop();
                }
              }, t4);
            }))).apply(this, arguments);
          }
          function P(t4, n4) {
            var r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, o2 = arguments.length > 3 ? arguments[3] : void 0, s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : e3.maxRetries || 3;
            return l(c().mark(function i2() {
              var a2, u3;
              return c().wrap(function(i3) {
                for (; ; ) switch (i3.prev = i3.next) {
                  case 0:
                    if (a2 = false, i3.prev = 1, !e3.startOffset && (null === (u3 = e3.includeChunks) || void 0 === u3 ? void 0 : u3.length) > 0 ? e3.includeChunks.includes(n4) && (a2 = true) : a2 = true, !a2) {
                      i3.next = 7;
                      break;
                    }
                    return a2 = false, i3.next = 7, e3.uploadFunction({ chunk: t4, index: n4, hash: k.hash, cancelToken: o2 });
                  case 7:
                    g++, w += t4.size, k.progress = g / y * 100, e3.onProgress && e3.onProgress(k.progress), i3.next = 29;
                    break;
                  case 13:
                    if (i3.prev = 13, i3.t0 = i3.catch(1), !f.isCancel(i3.t0)) {
                      i3.next = 18;
                      break;
                    }
                    return b.push({ chunk: t4, index: n4 }), i3.abrupt("return");
                  case 18:
                    if (!(r3 < s2)) {
                      i3.next = 23;
                      break;
                    }
                    return a2 = false, i3.abrupt("return", P(t4, n4, r3 + 1, o2)());
                  case 23:
                    if (k.errorMsg = i3.t0, "AxiosError" !== (null === i3.t0 || void 0 === i3.t0 ? void 0 : i3.t0.name)) {
                      i3.next = 28;
                      break;
                    }
                    throw new Error("chunk ".concat(n4, " upload fail，Maximum number of retries reached ").concat(s2, "."));
                  case 28:
                    throw i3.t0;
                  case 29:
                  case "end":
                    return i3.stop();
                }
              }, i2, null, [[1, 13]]);
            }));
          }
          function N() {
            E || (E = setInterval(function() {
              if (e3.onSpeed) {
                100 == k.progress.toFixed(0) && (_(), k.uploadEnd = true, e3.onSuccess && e3.onSuccess());
                var t4 = function(e4, t5) {
                  var n4 = t5 / 1048576 / ((performance.now() - e4 - S) / 1e3);
                  return n4 >= 1 ? "".concat(n4.toFixed(2), " MB/s") : "".concat((1024 * n4).toFixed(2), " KB/s");
                }(v, w);
                k.speed = t4, e3.onSpeed(t4);
              }
            }, 1e3));
          }
          function _() {
            E && (clearInterval(E), E = null);
          }
          function U() {
            return F.apply(this, arguments);
          }
          function F() {
            return F = l(c().mark(function t4() {
              var n4, o2, u3, g2, w2, v2, E2, S2, x2, O2 = arguments;
              return c().wrap(function(t5) {
                for (; ; ) switch (t5.prev = t5.next) {
                  case 0:
                    if (n4 = O2.length > 0 && void 0 !== O2[0] ? O2[0] : e3.concurrency || 5, 0 !== r2.length) {
                      t5.next = 3;
                      break;
                    }
                    throw new Error("The file slice has not been initialized. Please call the handleUpload method first.");
                  case 3:
                    for (o2 = Math.floor((e3.startOffset || 0) * (e3.chunkSize || 5242880) / (e3.chunkSize || 5242880)), u3 = JSON.parse(JSON.stringify(e3.includeChunks || [])), g2 = 0 === o2 && u3.length > 0, w2 = function() {
                      var e4 = l(c().mark(function e5() {
                        var t6, s2, i2, a2, l2;
                        return c().wrap(function(e6) {
                          for (; ; ) switch (e6.prev = e6.next) {
                            case 0:
                              if (!(p || h >= r2.length)) {
                                e6.next = 2;
                                break;
                              }
                              return e6.abrupt("return");
                            case 2:
                              if (!((t6 = g2 ? u3.shift() + o2 : h + o2) >= y)) {
                                e6.next = 7;
                                break;
                              }
                              return console.warn("Chunk index ".concat(t6, " is out of range. Skipping.")), h++, e6.abrupt("return");
                            case 7:
                              s2 = r2[h], i2 = f.CancelToken.source(), m.push(i2), a2 = P(s2, o2 + h, 0, i2.token), h++, l2 = a2().then(function() {
                                d = d.filter(function(e7) {
                                  return e7 !== l2;
                                }), w2();
                              }), d.push(l2), d.length < n4 && w2();
                            case 16:
                            case "end":
                              return e6.stop();
                          }
                        }, e5);
                      }));
                      return function() {
                        return e4.apply(this, arguments);
                      };
                    }(); d.length < n4 && h < r2.length; ) w2();
                    return t5.next = 10, Promise.all(d);
                  case 10:
                    if (!(b.length > 0) || p) {
                      t5.next = 31;
                      break;
                    }
                    v2 = function(e4) {
                      if (Array.isArray(e4)) return a(e4);
                    }(R2 = b) || function(e4) {
                      if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"]) return Array.from(e4);
                    }(R2) || i(R2) || function() {
                      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }(), b = [], E2 = s(v2), t5.prev = 14, x2 = c().mark(function e4() {
                      var t6, r3, s2, i2, a2, u4;
                      return c().wrap(function(e5) {
                        for (; ; ) switch (e5.prev = e5.next) {
                          case 0:
                            t6 = S2.value, r3 = t6.chunk, s2 = t6.index, i2 = f.CancelToken.source(), m.push(i2), a2 = P(r3, o2 + s2 - o2, 0, i2.token), u4 = a2().then(function() {
                              d = d.filter(function(e6) {
                                return e6 !== u4;
                              });
                            }), d.push(u4), d.length < n4 && w2();
                          case 8:
                          case "end":
                            return e5.stop();
                        }
                      }, e4);
                    }), E2.s();
                  case 17:
                    if ((S2 = E2.n()).done) {
                      t5.next = 21;
                      break;
                    }
                    return t5.delegateYield(x2(), "t0", 19);
                  case 19:
                    t5.next = 17;
                    break;
                  case 21:
                    t5.next = 26;
                    break;
                  case 23:
                    t5.prev = 23, t5.t1 = t5.catch(14), E2.e(t5.t1);
                  case 26:
                    return t5.prev = 26, E2.f(), t5.finish(26);
                  case 29:
                    return t5.next = 31, Promise.all(d);
                  case 31:
                  case "end":
                    return t5.stop();
                }
                var R2;
              }, t4, null, [[14, 23, 26, 29]]);
            })), F.apply(this, arguments);
          }
          function B() {
            return (B = l(c().mark(function e4() {
              return c().wrap(function(e5) {
                for (; ; ) switch (e5.prev = e5.next) {
                  case 0:
                    if (0 !== r2.length) {
                      e5.next = 3;
                      break;
                    }
                    return console.error("The file slice has not been initialized. Please call the handleUpload method first."), e5.abrupt("return");
                  case 3:
                    if (p) {
                      e5.next = 5;
                      break;
                    }
                    return e5.abrupt("return");
                  case 5:
                    return p = false, S += performance.now() - x, N(), e5.next = 10, U();
                  case 10:
                  case "end":
                    return e5.stop();
                }
              }, e4);
            }))).apply(this, arguments);
          }
          function M() {
            return (M = l(c().mark(function t4(n4) {
              var o2, s2, i2, a2, l2, f2, d2;
              return c().wrap(function(t5) {
                for (; ; ) switch (t5.prev = t5.next) {
                  case 0:
                    if (k.file = n4, l2 = (e3.startOffset || 0) * (e3.chunkSize || 5242880), 0 === h && (p = false, k.progress = 0), r2 = T(n4, e3.chunkSize || 5242880, l2), f2 = true === e3.chunkMap || (null === (o2 = e3.chunkMap) || void 0 === o2 ? void 0 : o2.enable) && !(null !== (s2 = e3.chunkMap) && void 0 !== s2 && s2.async), !((d2 = (null === (i2 = e3.chunkMap) || void 0 === i2 ? void 0 : i2.enable) && (null === (a2 = e3.chunkMap) || void 0 === a2 ? void 0 : a2.async)) && false !== e3.awaitHash || true !== e3.hash || 0 == e3.awaitHash && f2)) {
                      t5.next = 17;
                      break;
                    }
                    if (!f2) {
                      t5.next = 14;
                      break;
                    }
                    return t5.next = 10, A(r2, O);
                  case 10:
                    k.hashMap = t5.sent, console.log(k.hashMap, "sdfsdfsdf"), t5.next = 15;
                    break;
                  case 14:
                    d2 && A(r2, O).then(function(e4) {
                      k.hashMap = e4;
                    });
                  case 15:
                    t5.next = 18;
                    break;
                  case 17:
                    R = true;
                  case 18:
                    if (0 !== r2.length) {
                      t5.next = 20;
                      break;
                    }
                    throw new Error("The startOffset parameter is too large and the file slices array is empty.");
                  case 20:
                    if (y = r2.length + (e3.startOffset || 0), k.totalChunks = y, e3.beginHash && e3.hash && e3.beginHash(), false === e3.awaitHash) {
                      t5.next = 28;
                      break;
                    }
                    return t5.next = 26, C(r2);
                  case 26:
                    t5.next = 29;
                    break;
                  case 28:
                    C(r2);
                  case 29:
                    return u2 = k.hash, e3.endHash && e3.hash && e3.endHash(u2), h = 0, g = e3.startOffset || 0, b = [], w = 0, S = 0, v = performance.now(), N(), t5.next = 40, U();
                  case 40:
                  case "end":
                    return t5.stop();
                }
              }, t4);
            }))).apply(this, arguments);
          }
          return { upload: function(e4) {
            return M.apply(this, arguments);
          }, pause: function() {
            p = true, _(), x = performance.now(), m.forEach(function(e4) {
              return e4.cancel("Upload suspended");
            }), m = [];
          }, resume: function() {
            return B.apply(this, arguments);
          }, reset: function() {
            m.forEach(function(e4) {
              return e4.cancel("Upload reset");
            }), r2 = [], u2 = null, h = 0, p = false, d = [], m = [], y = 0, g = 0, b = [], w = 0, S = 0, x = 0, E && (clearInterval(E), E = null), Object.keys(k).forEach(function(e4) {
              "progress" === e4 || "speed" === e4 ? k[e4] = 0 : "uploadEnd" === e4 ? k[e4] = false : "hash" === e4 || "file" === e4 || "totalChunks" === e4 || "errorMsg" === e4 ? k[e4] = "" : "allChunks" === e4 ? k[e4] = [] : "hashMap" === e4 && (k[e4] = /* @__PURE__ */ new Map());
            });
          }, state: k };
        };
      }, 806: (e2, t2, n2) => {
        "use strict";
        function r(e3, t3) {
          return function() {
            return e3.apply(t3, arguments);
          };
        }
        const { toString: o } = Object.prototype, { getPrototypeOf: s } = Object, i = (a = /* @__PURE__ */ Object.create(null), (e3) => {
          const t3 = o.call(e3);
          return a[t3] || (a[t3] = t3.slice(8, -1).toLowerCase());
        });
        var a;
        const c = (e3) => (e3 = e3.toLowerCase(), (t3) => i(t3) === e3), u = (e3) => (t3) => typeof t3 === e3, { isArray: l } = Array, f = u("undefined"), h = c("ArrayBuffer"), p = u("string"), d = u("function"), m = u("number"), y = (e3) => null !== e3 && "object" == typeof e3, g = (e3) => {
          if ("object" !== i(e3)) return false;
          const t3 = s(e3);
          return !(null !== t3 && t3 !== Object.prototype && null !== Object.getPrototypeOf(t3) || Symbol.toStringTag in e3 || Symbol.iterator in e3);
        }, b = c("Date"), w = c("File"), v = c("Blob"), E = c("FileList"), S = c("URLSearchParams"), [x, O, R, k] = ["ReadableStream", "Request", "Response", "Headers"].map(c);
        function T(e3, t3, { allOwnKeys: n3 = false } = {}) {
          if (null == e3) return;
          let r2, o2;
          if ("object" != typeof e3 && (e3 = [e3]), l(e3)) for (r2 = 0, o2 = e3.length; r2 < o2; r2++) t3.call(null, e3[r2], r2, e3);
          else {
            const o3 = n3 ? Object.getOwnPropertyNames(e3) : Object.keys(e3), s2 = o3.length;
            let i2;
            for (r2 = 0; r2 < s2; r2++) i2 = o3[r2], t3.call(null, e3[i2], i2, e3);
          }
        }
        function A(e3, t3) {
          t3 = t3.toLowerCase();
          const n3 = Object.keys(e3);
          let r2, o2 = n3.length;
          for (; o2-- > 0; ) if (r2 = n3[o2], t3 === r2.toLowerCase()) return r2;
          return null;
        }
        const j = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : n2.g, C = (e3) => !f(e3) && e3 !== j, L = (P = "undefined" != typeof Uint8Array && s(Uint8Array), (e3) => P && e3 instanceof P);
        var P;
        const N = c("HTMLFormElement"), _ = (({ hasOwnProperty: e3 }) => (t3, n3) => e3.call(t3, n3))(Object.prototype), U = c("RegExp"), F = (e3, t3) => {
          const n3 = Object.getOwnPropertyDescriptors(e3), r2 = {};
          T(n3, (n4, o2) => {
            let s2;
            false !== (s2 = t3(n4, o2, e3)) && (r2[o2] = s2 || n4);
          }), Object.defineProperties(e3, r2);
        }, B = "abcdefghijklmnopqrstuvwxyz", M = "0123456789", D = { DIGIT: M, ALPHA: B, ALPHA_DIGIT: B + B.toUpperCase() + M }, H = c("AsyncFunction");
        var I = { isArray: l, isArrayBuffer: h, isBuffer: function(e3) {
          return null !== e3 && !f(e3) && null !== e3.constructor && !f(e3.constructor) && d(e3.constructor.isBuffer) && e3.constructor.isBuffer(e3);
        }, isFormData: (e3) => {
          let t3;
          return e3 && ("function" == typeof FormData && e3 instanceof FormData || d(e3.append) && ("formdata" === (t3 = i(e3)) || "object" === t3 && d(e3.toString) && "[object FormData]" === e3.toString()));
        }, isArrayBufferView: function(e3) {
          let t3;
          return t3 = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e3) : e3 && e3.buffer && h(e3.buffer), t3;
        }, isString: p, isNumber: m, isBoolean: (e3) => true === e3 || false === e3, isObject: y, isPlainObject: g, isReadableStream: x, isRequest: O, isResponse: R, isHeaders: k, isUndefined: f, isDate: b, isFile: w, isBlob: v, isRegExp: U, isFunction: d, isStream: (e3) => y(e3) && d(e3.pipe), isURLSearchParams: S, isTypedArray: L, isFileList: E, forEach: T, merge: function e3() {
          const { caseless: t3 } = C(this) && this || {}, n3 = {}, r2 = (r3, o2) => {
            const s2 = t3 && A(n3, o2) || o2;
            g(n3[s2]) && g(r3) ? n3[s2] = e3(n3[s2], r3) : g(r3) ? n3[s2] = e3({}, r3) : l(r3) ? n3[s2] = r3.slice() : n3[s2] = r3;
          };
          for (let e4 = 0, t4 = arguments.length; e4 < t4; e4++) arguments[e4] && T(arguments[e4], r2);
          return n3;
        }, extend: (e3, t3, n3, { allOwnKeys: o2 } = {}) => (T(t3, (t4, o3) => {
          n3 && d(t4) ? e3[o3] = r(t4, n3) : e3[o3] = t4;
        }, { allOwnKeys: o2 }), e3), trim: (e3) => e3.trim ? e3.trim() : e3.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: (e3) => (65279 === e3.charCodeAt(0) && (e3 = e3.slice(1)), e3), inherits: (e3, t3, n3, r2) => {
          e3.prototype = Object.create(t3.prototype, r2), e3.prototype.constructor = e3, Object.defineProperty(e3, "super", { value: t3.prototype }), n3 && Object.assign(e3.prototype, n3);
        }, toFlatObject: (e3, t3, n3, r2) => {
          let o2, i2, a2;
          const c2 = {};
          if (t3 = t3 || {}, null == e3) return t3;
          do {
            for (o2 = Object.getOwnPropertyNames(e3), i2 = o2.length; i2-- > 0; ) a2 = o2[i2], r2 && !r2(a2, e3, t3) || c2[a2] || (t3[a2] = e3[a2], c2[a2] = true);
            e3 = false !== n3 && s(e3);
          } while (e3 && (!n3 || n3(e3, t3)) && e3 !== Object.prototype);
          return t3;
        }, kindOf: i, kindOfTest: c, endsWith: (e3, t3, n3) => {
          e3 = String(e3), (void 0 === n3 || n3 > e3.length) && (n3 = e3.length), n3 -= t3.length;
          const r2 = e3.indexOf(t3, n3);
          return -1 !== r2 && r2 === n3;
        }, toArray: (e3) => {
          if (!e3) return null;
          if (l(e3)) return e3;
          let t3 = e3.length;
          if (!m(t3)) return null;
          const n3 = new Array(t3);
          for (; t3-- > 0; ) n3[t3] = e3[t3];
          return n3;
        }, forEachEntry: (e3, t3) => {
          const n3 = (e3 && e3[Symbol.iterator]).call(e3);
          let r2;
          for (; (r2 = n3.next()) && !r2.done; ) {
            const n4 = r2.value;
            t3.call(e3, n4[0], n4[1]);
          }
        }, matchAll: (e3, t3) => {
          let n3;
          const r2 = [];
          for (; null !== (n3 = e3.exec(t3)); ) r2.push(n3);
          return r2;
        }, isHTMLForm: N, hasOwnProperty: _, hasOwnProp: _, reduceDescriptors: F, freezeMethods: (e3) => {
          F(e3, (t3, n3) => {
            if (d(e3) && -1 !== ["arguments", "caller", "callee"].indexOf(n3)) return false;
            const r2 = e3[n3];
            d(r2) && (t3.enumerable = false, "writable" in t3 ? t3.writable = false : t3.set || (t3.set = () => {
              throw Error("Can not rewrite read-only method '" + n3 + "'");
            }));
          });
        }, toObjectSet: (e3, t3) => {
          const n3 = {}, r2 = (e4) => {
            e4.forEach((e5) => {
              n3[e5] = true;
            });
          };
          return l(e3) ? r2(e3) : r2(String(e3).split(t3)), n3;
        }, toCamelCase: (e3) => e3.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(e4, t3, n3) {
          return t3.toUpperCase() + n3;
        }), noop: () => {
        }, toFiniteNumber: (e3, t3) => null != e3 && Number.isFinite(e3 = +e3) ? e3 : t3, findKey: A, global: j, isContextDefined: C, ALPHABET: D, generateString: (e3 = 16, t3 = D.ALPHA_DIGIT) => {
          let n3 = "";
          const { length: r2 } = t3;
          for (; e3--; ) n3 += t3[Math.random() * r2 | 0];
          return n3;
        }, isSpecCompliantForm: function(e3) {
          return !!(e3 && d(e3.append) && "FormData" === e3[Symbol.toStringTag] && e3[Symbol.iterator]);
        }, toJSONObject: (e3) => {
          const t3 = new Array(10), n3 = (e4, r2) => {
            if (y(e4)) {
              if (t3.indexOf(e4) >= 0) return;
              if (!("toJSON" in e4)) {
                t3[r2] = e4;
                const o2 = l(e4) ? [] : {};
                return T(e4, (e5, t4) => {
                  const s2 = n3(e5, r2 + 1);
                  !f(s2) && (o2[t4] = s2);
                }), t3[r2] = void 0, o2;
              }
            }
            return e4;
          };
          return n3(e3, 0);
        }, isAsyncFn: H, isThenable: (e3) => e3 && (y(e3) || d(e3)) && d(e3.then) && d(e3.catch) };
        function q(e3, t3, n3, r2, o2) {
          Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e3, this.name = "AxiosError", t3 && (this.code = t3), n3 && (this.config = n3), r2 && (this.request = r2), o2 && (this.response = o2);
        }
        I.inherits(q, Error, { toJSON: function() {
          return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: I.toJSONObject(this.config), code: this.code, status: this.response && this.response.status ? this.response.status : null };
        } });
        const z = q.prototype, J = {};
        function W(e3) {
          return I.isPlainObject(e3) || I.isArray(e3);
        }
        function V(e3) {
          return I.endsWith(e3, "[]") ? e3.slice(0, -2) : e3;
        }
        function K(e3, t3, n3) {
          return e3 ? e3.concat(t3).map(function(e4, t4) {
            return e4 = V(e4), !n3 && t4 ? "[" + e4 + "]" : e4;
          }).join(n3 ? "." : "") : t3;
        }
        ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e3) => {
          J[e3] = { value: e3 };
        }), Object.defineProperties(q, J), Object.defineProperty(z, "isAxiosError", { value: true }), q.from = (e3, t3, n3, r2, o2, s2) => {
          const i2 = Object.create(z);
          return I.toFlatObject(e3, i2, function(e4) {
            return e4 !== Error.prototype;
          }, (e4) => "isAxiosError" !== e4), q.call(i2, e3.message, t3, n3, r2, o2), i2.cause = e3, i2.name = e3.name, s2 && Object.assign(i2, s2), i2;
        };
        const G = I.toFlatObject(I, {}, null, function(e3) {
          return /^is[A-Z]/.test(e3);
        });
        function $(e3, t3, n3) {
          if (!I.isObject(e3)) throw new TypeError("target must be an object");
          t3 = t3 || new FormData();
          const r2 = (n3 = I.toFlatObject(n3, { metaTokens: true, dots: false, indexes: false }, false, function(e4, t4) {
            return !I.isUndefined(t4[e4]);
          })).metaTokens, o2 = n3.visitor || u2, s2 = n3.dots, i2 = n3.indexes, a2 = (n3.Blob || "undefined" != typeof Blob && Blob) && I.isSpecCompliantForm(t3);
          if (!I.isFunction(o2)) throw new TypeError("visitor must be a function");
          function c2(e4) {
            if (null === e4) return "";
            if (I.isDate(e4)) return e4.toISOString();
            if (!a2 && I.isBlob(e4)) throw new q("Blob is not supported. Use a Buffer instead.");
            return I.isArrayBuffer(e4) || I.isTypedArray(e4) ? a2 && "function" == typeof Blob ? new Blob([e4]) : Buffer.from(e4) : e4;
          }
          function u2(e4, n4, o3) {
            let a3 = e4;
            if (e4 && !o3 && "object" == typeof e4) {
              if (I.endsWith(n4, "{}")) n4 = r2 ? n4 : n4.slice(0, -2), e4 = JSON.stringify(e4);
              else if (I.isArray(e4) && function(e5) {
                return I.isArray(e5) && !e5.some(W);
              }(e4) || (I.isFileList(e4) || I.endsWith(n4, "[]")) && (a3 = I.toArray(e4))) return n4 = V(n4), a3.forEach(function(e5, r3) {
                !I.isUndefined(e5) && null !== e5 && t3.append(true === i2 ? K([n4], r3, s2) : null === i2 ? n4 : n4 + "[]", c2(e5));
              }), false;
            }
            return !!W(e4) || (t3.append(K(o3, n4, s2), c2(e4)), false);
          }
          const l2 = [], f2 = Object.assign(G, { defaultVisitor: u2, convertValue: c2, isVisitable: W });
          if (!I.isObject(e3)) throw new TypeError("data must be an object");
          return function e4(n4, r3) {
            if (!I.isUndefined(n4)) {
              if (-1 !== l2.indexOf(n4)) throw Error("Circular reference detected in " + r3.join("."));
              l2.push(n4), I.forEach(n4, function(n5, s3) {
                true === (!(I.isUndefined(n5) || null === n5) && o2.call(t3, n5, I.isString(s3) ? s3.trim() : s3, r3, f2)) && e4(n5, r3 ? r3.concat(s3) : [s3]);
              }), l2.pop();
            }
          }(e3), t3;
        }
        function X(e3) {
          const t3 = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
          return encodeURIComponent(e3).replace(/[!'()~]|%20|%00/g, function(e4) {
            return t3[e4];
          });
        }
        function Y(e3, t3) {
          this._pairs = [], e3 && $(e3, this, t3);
        }
        const Q = Y.prototype;
        function Z(e3) {
          return encodeURIComponent(e3).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        }
        function ee(e3, t3, n3) {
          if (!t3) return e3;
          const r2 = n3 && n3.encode || Z, o2 = n3 && n3.serialize;
          let s2;
          if (s2 = o2 ? o2(t3, n3) : I.isURLSearchParams(t3) ? t3.toString() : new Y(t3, n3).toString(r2), s2) {
            const t4 = e3.indexOf("#");
            -1 !== t4 && (e3 = e3.slice(0, t4)), e3 += (-1 === e3.indexOf("?") ? "?" : "&") + s2;
          }
          return e3;
        }
        Q.append = function(e3, t3) {
          this._pairs.push([e3, t3]);
        }, Q.toString = function(e3) {
          const t3 = e3 ? function(t4) {
            return e3.call(this, t4, X);
          } : X;
          return this._pairs.map(function(e4) {
            return t3(e4[0]) + "=" + t3(e4[1]);
          }, "").join("&");
        };
        var te = class {
          constructor() {
            this.handlers = [];
          }
          use(e3, t3, n3) {
            return this.handlers.push({ fulfilled: e3, rejected: t3, synchronous: !!n3 && n3.synchronous, runWhen: n3 ? n3.runWhen : null }), this.handlers.length - 1;
          }
          eject(e3) {
            this.handlers[e3] && (this.handlers[e3] = null);
          }
          clear() {
            this.handlers && (this.handlers = []);
          }
          forEach(e3) {
            I.forEach(this.handlers, function(t3) {
              null !== t3 && e3(t3);
            });
          }
        }, ne = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, re = { isBrowser: true, classes: { URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : Y, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] };
        const oe = "undefined" != typeof window && "undefined" != typeof document, se = (ie = "undefined" != typeof navigator && navigator.product, oe && ["ReactNative", "NativeScript", "NS"].indexOf(ie) < 0);
        var ie;
        const ae = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts, ce = oe && window.location.href || "http://localhost";
        var ue = { ...Object.freeze({ __proto__: null, hasBrowserEnv: oe, hasStandardBrowserWebWorkerEnv: ae, hasStandardBrowserEnv: se, origin: ce }), ...re };
        function le(e3) {
          function t3(e4, n3, r2, o2) {
            let s2 = e4[o2++];
            if ("__proto__" === s2) return true;
            const i2 = Number.isFinite(+s2), a2 = o2 >= e4.length;
            return s2 = !s2 && I.isArray(r2) ? r2.length : s2, a2 ? (I.hasOwnProp(r2, s2) ? r2[s2] = [r2[s2], n3] : r2[s2] = n3, !i2) : (r2[s2] && I.isObject(r2[s2]) || (r2[s2] = []), t3(e4, n3, r2[s2], o2) && I.isArray(r2[s2]) && (r2[s2] = function(e5) {
              const t4 = {}, n4 = Object.keys(e5);
              let r3;
              const o3 = n4.length;
              let s3;
              for (r3 = 0; r3 < o3; r3++) s3 = n4[r3], t4[s3] = e5[s3];
              return t4;
            }(r2[s2])), !i2);
          }
          if (I.isFormData(e3) && I.isFunction(e3.entries)) {
            const n3 = {};
            return I.forEachEntry(e3, (e4, r2) => {
              t3(function(e5) {
                return I.matchAll(/\w+|\[(\w*)]/g, e5).map((e6) => "[]" === e6[0] ? "" : e6[1] || e6[0]);
              }(e4), r2, n3, 0);
            }), n3;
          }
          return null;
        }
        const fe = { transitional: ne, adapter: ["xhr", "http", "fetch"], transformRequest: [function(e3, t3) {
          const n3 = t3.getContentType() || "", r2 = n3.indexOf("application/json") > -1, o2 = I.isObject(e3);
          if (o2 && I.isHTMLForm(e3) && (e3 = new FormData(e3)), I.isFormData(e3)) return r2 ? JSON.stringify(le(e3)) : e3;
          if (I.isArrayBuffer(e3) || I.isBuffer(e3) || I.isStream(e3) || I.isFile(e3) || I.isBlob(e3) || I.isReadableStream(e3)) return e3;
          if (I.isArrayBufferView(e3)) return e3.buffer;
          if (I.isURLSearchParams(e3)) return t3.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), e3.toString();
          let s2;
          if (o2) {
            if (n3.indexOf("application/x-www-form-urlencoded") > -1) return function(e4, t4) {
              return $(e4, new ue.classes.URLSearchParams(), Object.assign({ visitor: function(e5, t5, n4, r3) {
                return ue.isNode && I.isBuffer(e5) ? (this.append(t5, e5.toString("base64")), false) : r3.defaultVisitor.apply(this, arguments);
              } }, t4));
            }(e3, this.formSerializer).toString();
            if ((s2 = I.isFileList(e3)) || n3.indexOf("multipart/form-data") > -1) {
              const t4 = this.env && this.env.FormData;
              return $(s2 ? { "files[]": e3 } : e3, t4 && new t4(), this.formSerializer);
            }
          }
          return o2 || r2 ? (t3.setContentType("application/json", false), function(e4, t4, n4) {
            if (I.isString(e4)) try {
              return (0, JSON.parse)(e4), I.trim(e4);
            } catch (e5) {
              if ("SyntaxError" !== e5.name) throw e5;
            }
            return (0, JSON.stringify)(e4);
          }(e3)) : e3;
        }], transformResponse: [function(e3) {
          const t3 = this.transitional || fe.transitional, n3 = t3 && t3.forcedJSONParsing, r2 = "json" === this.responseType;
          if (I.isResponse(e3) || I.isReadableStream(e3)) return e3;
          if (e3 && I.isString(e3) && (n3 && !this.responseType || r2)) {
            const n4 = !(t3 && t3.silentJSONParsing) && r2;
            try {
              return JSON.parse(e3);
            } catch (e4) {
              if (n4) {
                if ("SyntaxError" === e4.name) throw q.from(e4, q.ERR_BAD_RESPONSE, this, null, this.response);
                throw e4;
              }
            }
          }
          return e3;
        }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: ue.classes.FormData, Blob: ue.classes.Blob }, validateStatus: function(e3) {
          return e3 >= 200 && e3 < 300;
        }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } };
        I.forEach(["delete", "get", "head", "post", "put", "patch"], (e3) => {
          fe.headers[e3] = {};
        });
        var he = fe;
        const pe = I.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), de = Symbol("internals");
        function me(e3) {
          return e3 && String(e3).trim().toLowerCase();
        }
        function ye(e3) {
          return false === e3 || null == e3 ? e3 : I.isArray(e3) ? e3.map(ye) : String(e3);
        }
        function ge(e3, t3, n3, r2, o2) {
          return I.isFunction(r2) ? r2.call(this, t3, n3) : (o2 && (t3 = n3), I.isString(t3) ? I.isString(r2) ? -1 !== t3.indexOf(r2) : I.isRegExp(r2) ? r2.test(t3) : void 0 : void 0);
        }
        class be {
          constructor(e3) {
            e3 && this.set(e3);
          }
          set(e3, t3, n3) {
            const r2 = this;
            function o2(e4, t4, n4) {
              const o3 = me(t4);
              if (!o3) throw new Error("header name must be a non-empty string");
              const s3 = I.findKey(r2, o3);
              (!s3 || void 0 === r2[s3] || true === n4 || void 0 === n4 && false !== r2[s3]) && (r2[s3 || t4] = ye(e4));
            }
            const s2 = (e4, t4) => I.forEach(e4, (e5, n4) => o2(e5, n4, t4));
            if (I.isPlainObject(e3) || e3 instanceof this.constructor) s2(e3, t3);
            else if (I.isString(e3) && (e3 = e3.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e3.trim())) s2(((e4) => {
              const t4 = {};
              let n4, r3, o3;
              return e4 && e4.split("\n").forEach(function(e5) {
                o3 = e5.indexOf(":"), n4 = e5.substring(0, o3).trim().toLowerCase(), r3 = e5.substring(o3 + 1).trim(), !n4 || t4[n4] && pe[n4] || ("set-cookie" === n4 ? t4[n4] ? t4[n4].push(r3) : t4[n4] = [r3] : t4[n4] = t4[n4] ? t4[n4] + ", " + r3 : r3);
              }), t4;
            })(e3), t3);
            else if (I.isHeaders(e3)) for (const [t4, r3] of e3.entries()) o2(r3, t4, n3);
            else null != e3 && o2(t3, e3, n3);
            return this;
          }
          get(e3, t3) {
            if (e3 = me(e3)) {
              const n3 = I.findKey(this, e3);
              if (n3) {
                const e4 = this[n3];
                if (!t3) return e4;
                if (true === t3) return function(e5) {
                  const t4 = /* @__PURE__ */ Object.create(null), n4 = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                  let r2;
                  for (; r2 = n4.exec(e5); ) t4[r2[1]] = r2[2];
                  return t4;
                }(e4);
                if (I.isFunction(t3)) return t3.call(this, e4, n3);
                if (I.isRegExp(t3)) return t3.exec(e4);
                throw new TypeError("parser must be boolean|regexp|function");
              }
            }
          }
          has(e3, t3) {
            if (e3 = me(e3)) {
              const n3 = I.findKey(this, e3);
              return !(!n3 || void 0 === this[n3] || t3 && !ge(0, this[n3], n3, t3));
            }
            return false;
          }
          delete(e3, t3) {
            const n3 = this;
            let r2 = false;
            function o2(e4) {
              if (e4 = me(e4)) {
                const o3 = I.findKey(n3, e4);
                !o3 || t3 && !ge(0, n3[o3], o3, t3) || (delete n3[o3], r2 = true);
              }
            }
            return I.isArray(e3) ? e3.forEach(o2) : o2(e3), r2;
          }
          clear(e3) {
            const t3 = Object.keys(this);
            let n3 = t3.length, r2 = false;
            for (; n3--; ) {
              const o2 = t3[n3];
              e3 && !ge(0, this[o2], o2, e3, true) || (delete this[o2], r2 = true);
            }
            return r2;
          }
          normalize(e3) {
            const t3 = this, n3 = {};
            return I.forEach(this, (r2, o2) => {
              const s2 = I.findKey(n3, o2);
              if (s2) return t3[s2] = ye(r2), void delete t3[o2];
              const i2 = e3 ? function(e4) {
                return e4.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e5, t4, n4) => t4.toUpperCase() + n4);
              }(o2) : String(o2).trim();
              i2 !== o2 && delete t3[o2], t3[i2] = ye(r2), n3[i2] = true;
            }), this;
          }
          concat(...e3) {
            return this.constructor.concat(this, ...e3);
          }
          toJSON(e3) {
            const t3 = /* @__PURE__ */ Object.create(null);
            return I.forEach(this, (n3, r2) => {
              null != n3 && false !== n3 && (t3[r2] = e3 && I.isArray(n3) ? n3.join(", ") : n3);
            }), t3;
          }
          [Symbol.iterator]() {
            return Object.entries(this.toJSON())[Symbol.iterator]();
          }
          toString() {
            return Object.entries(this.toJSON()).map(([e3, t3]) => e3 + ": " + t3).join("\n");
          }
          get [Symbol.toStringTag]() {
            return "AxiosHeaders";
          }
          static from(e3) {
            return e3 instanceof this ? e3 : new this(e3);
          }
          static concat(e3, ...t3) {
            const n3 = new this(e3);
            return t3.forEach((e4) => n3.set(e4)), n3;
          }
          static accessor(e3) {
            const t3 = (this[de] = this[de] = { accessors: {} }).accessors, n3 = this.prototype;
            function r2(e4) {
              const r3 = me(e4);
              t3[r3] || (function(e5, t4) {
                const n4 = I.toCamelCase(" " + t4);
                ["get", "set", "has"].forEach((r4) => {
                  Object.defineProperty(e5, r4 + n4, { value: function(e6, n5, o2) {
                    return this[r4].call(this, t4, e6, n5, o2);
                  }, configurable: true });
                });
              }(n3, e4), t3[r3] = true);
            }
            return I.isArray(e3) ? e3.forEach(r2) : r2(e3), this;
          }
        }
        be.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), I.reduceDescriptors(be.prototype, ({ value: e3 }, t3) => {
          let n3 = t3[0].toUpperCase() + t3.slice(1);
          return { get: () => e3, set(e4) {
            this[n3] = e4;
          } };
        }), I.freezeMethods(be);
        var we = be;
        function ve(e3, t3) {
          const n3 = this || he, r2 = t3 || n3, o2 = we.from(r2.headers);
          let s2 = r2.data;
          return I.forEach(e3, function(e4) {
            s2 = e4.call(n3, s2, o2.normalize(), t3 ? t3.status : void 0);
          }), o2.normalize(), s2;
        }
        function Ee(e3) {
          return !(!e3 || !e3.__CANCEL__);
        }
        function Se(e3, t3, n3) {
          q.call(this, null == e3 ? "canceled" : e3, q.ERR_CANCELED, t3, n3), this.name = "CanceledError";
        }
        function xe(e3, t3, n3) {
          const r2 = n3.config.validateStatus;
          n3.status && r2 && !r2(n3.status) ? t3(new q("Request failed with status code " + n3.status, [q.ERR_BAD_REQUEST, q.ERR_BAD_RESPONSE][Math.floor(n3.status / 100) - 4], n3.config, n3.request, n3)) : e3(n3);
        }
        I.inherits(Se, q, { __CANCEL__: true });
        var Oe = (e3, t3, n3 = 3) => {
          let r2 = 0;
          const o2 = function(e4, t4) {
            e4 = e4 || 10;
            const n4 = new Array(e4), r3 = new Array(e4);
            let o3, s2 = 0, i2 = 0;
            return t4 = void 0 !== t4 ? t4 : 1e3, function(a2) {
              const c2 = Date.now(), u2 = r3[i2];
              o3 || (o3 = c2), n4[s2] = a2, r3[s2] = c2;
              let l2 = i2, f2 = 0;
              for (; l2 !== s2; ) f2 += n4[l2++], l2 %= e4;
              if (s2 = (s2 + 1) % e4, s2 === i2 && (i2 = (i2 + 1) % e4), c2 - o3 < t4) return;
              const h2 = u2 && c2 - u2;
              return h2 ? Math.round(1e3 * f2 / h2) : void 0;
            };
          }(50, 250);
          return function(e4, t4) {
            let n4 = 0;
            const r3 = 1e3 / t4;
            let o3 = null;
            return function() {
              const t5 = true === this, s2 = Date.now();
              if (t5 || s2 - n4 > r3) return o3 && (clearTimeout(o3), o3 = null), n4 = s2, e4.apply(null, arguments);
              o3 || (o3 = setTimeout(() => (o3 = null, n4 = Date.now(), e4.apply(null, arguments)), r3 - (s2 - n4)));
            };
          }((n4) => {
            const s2 = n4.loaded, i2 = n4.lengthComputable ? n4.total : void 0, a2 = s2 - r2, c2 = o2(a2);
            r2 = s2;
            const u2 = { loaded: s2, total: i2, progress: i2 ? s2 / i2 : void 0, bytes: a2, rate: c2 || void 0, estimated: c2 && i2 && s2 <= i2 ? (i2 - s2) / c2 : void 0, event: n4, lengthComputable: null != i2 };
            u2[t3 ? "download" : "upload"] = true, e3(u2);
          }, n3);
        }, Re = ue.hasStandardBrowserEnv ? function() {
          const e3 = /(msie|trident)/i.test(navigator.userAgent), t3 = document.createElement("a");
          let n3;
          function r2(n4) {
            let r3 = n4;
            return e3 && (t3.setAttribute("href", r3), r3 = t3.href), t3.setAttribute("href", r3), { href: t3.href, protocol: t3.protocol ? t3.protocol.replace(/:$/, "") : "", host: t3.host, search: t3.search ? t3.search.replace(/^\?/, "") : "", hash: t3.hash ? t3.hash.replace(/^#/, "") : "", hostname: t3.hostname, port: t3.port, pathname: "/" === t3.pathname.charAt(0) ? t3.pathname : "/" + t3.pathname };
          }
          return n3 = r2(window.location.href), function(e4) {
            const t4 = I.isString(e4) ? r2(e4) : e4;
            return t4.protocol === n3.protocol && t4.host === n3.host;
          };
        }() : function() {
          return true;
        }, ke = ue.hasStandardBrowserEnv ? { write(e3, t3, n3, r2, o2, s2) {
          const i2 = [e3 + "=" + encodeURIComponent(t3)];
          I.isNumber(n3) && i2.push("expires=" + new Date(n3).toGMTString()), I.isString(r2) && i2.push("path=" + r2), I.isString(o2) && i2.push("domain=" + o2), true === s2 && i2.push("secure"), document.cookie = i2.join("; ");
        }, read(e3) {
          const t3 = document.cookie.match(new RegExp("(^|;\\s*)(" + e3 + ")=([^;]*)"));
          return t3 ? decodeURIComponent(t3[3]) : null;
        }, remove(e3) {
          this.write(e3, "", Date.now() - 864e5);
        } } : { write() {
        }, read: () => null, remove() {
        } };
        function Te(e3, t3) {
          return e3 && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t3) ? function(e4, t4) {
            return t4 ? e4.replace(/\/?\/$/, "") + "/" + t4.replace(/^\/+/, "") : e4;
          }(e3, t3) : t3;
        }
        const Ae = (e3) => e3 instanceof we ? { ...e3 } : e3;
        function je(e3, t3) {
          t3 = t3 || {};
          const n3 = {};
          function r2(e4, t4, n4) {
            return I.isPlainObject(e4) && I.isPlainObject(t4) ? I.merge.call({ caseless: n4 }, e4, t4) : I.isPlainObject(t4) ? I.merge({}, t4) : I.isArray(t4) ? t4.slice() : t4;
          }
          function o2(e4, t4, n4) {
            return I.isUndefined(t4) ? I.isUndefined(e4) ? void 0 : r2(void 0, e4, n4) : r2(e4, t4, n4);
          }
          function s2(e4, t4) {
            if (!I.isUndefined(t4)) return r2(void 0, t4);
          }
          function i2(e4, t4) {
            return I.isUndefined(t4) ? I.isUndefined(e4) ? void 0 : r2(void 0, e4) : r2(void 0, t4);
          }
          function a2(n4, o3, s3) {
            return s3 in t3 ? r2(n4, o3) : s3 in e3 ? r2(void 0, n4) : void 0;
          }
          const c2 = { url: s2, method: s2, data: s2, baseURL: i2, transformRequest: i2, transformResponse: i2, paramsSerializer: i2, timeout: i2, timeoutMessage: i2, withCredentials: i2, withXSRFToken: i2, adapter: i2, responseType: i2, xsrfCookieName: i2, xsrfHeaderName: i2, onUploadProgress: i2, onDownloadProgress: i2, decompress: i2, maxContentLength: i2, maxBodyLength: i2, beforeRedirect: i2, transport: i2, httpAgent: i2, httpsAgent: i2, cancelToken: i2, socketPath: i2, responseEncoding: i2, validateStatus: a2, headers: (e4, t4) => o2(Ae(e4), Ae(t4), true) };
          return I.forEach(Object.keys(Object.assign({}, e3, t3)), function(r3) {
            const s3 = c2[r3] || o2, i3 = s3(e3[r3], t3[r3], r3);
            I.isUndefined(i3) && s3 !== a2 || (n3[r3] = i3);
          }), n3;
        }
        var Ce = (e3) => {
          const t3 = je({}, e3);
          let n3, { data: r2, withXSRFToken: o2, xsrfHeaderName: s2, xsrfCookieName: i2, headers: a2, auth: c2 } = t3;
          if (t3.headers = a2 = we.from(a2), t3.url = ee(Te(t3.baseURL, t3.url), e3.params, e3.paramsSerializer), c2 && a2.set("Authorization", "Basic " + btoa((c2.username || "") + ":" + (c2.password ? unescape(encodeURIComponent(c2.password)) : ""))), I.isFormData(r2)) {
            if (ue.hasStandardBrowserEnv || ue.hasStandardBrowserWebWorkerEnv) a2.setContentType(void 0);
            else if (false !== (n3 = a2.getContentType())) {
              const [e4, ...t4] = n3 ? n3.split(";").map((e5) => e5.trim()).filter(Boolean) : [];
              a2.setContentType([e4 || "multipart/form-data", ...t4].join("; "));
            }
          }
          if (ue.hasStandardBrowserEnv && (o2 && I.isFunction(o2) && (o2 = o2(t3)), o2 || false !== o2 && Re(t3.url))) {
            const e4 = s2 && i2 && ke.read(i2);
            e4 && a2.set(s2, e4);
          }
          return t3;
        }, Le = "undefined" != typeof XMLHttpRequest && function(e3) {
          return new Promise(function(t3, n3) {
            const r2 = Ce(e3);
            let o2 = r2.data;
            const s2 = we.from(r2.headers).normalize();
            let i2, { responseType: a2 } = r2;
            function c2() {
              r2.cancelToken && r2.cancelToken.unsubscribe(i2), r2.signal && r2.signal.removeEventListener("abort", i2);
            }
            let u2 = new XMLHttpRequest();
            function l2() {
              if (!u2) return;
              const r3 = we.from("getAllResponseHeaders" in u2 && u2.getAllResponseHeaders());
              xe(function(e4) {
                t3(e4), c2();
              }, function(e4) {
                n3(e4), c2();
              }, { data: a2 && "text" !== a2 && "json" !== a2 ? u2.response : u2.responseText, status: u2.status, statusText: u2.statusText, headers: r3, config: e3, request: u2 }), u2 = null;
            }
            u2.open(r2.method.toUpperCase(), r2.url, true), u2.timeout = r2.timeout, "onloadend" in u2 ? u2.onloadend = l2 : u2.onreadystatechange = function() {
              u2 && 4 === u2.readyState && (0 !== u2.status || u2.responseURL && 0 === u2.responseURL.indexOf("file:")) && setTimeout(l2);
            }, u2.onabort = function() {
              u2 && (n3(new q("Request aborted", q.ECONNABORTED, r2, u2)), u2 = null);
            }, u2.onerror = function() {
              n3(new q("Network Error", q.ERR_NETWORK, r2, u2)), u2 = null;
            }, u2.ontimeout = function() {
              let e4 = r2.timeout ? "timeout of " + r2.timeout + "ms exceeded" : "timeout exceeded";
              const t4 = r2.transitional || ne;
              r2.timeoutErrorMessage && (e4 = r2.timeoutErrorMessage), n3(new q(e4, t4.clarifyTimeoutError ? q.ETIMEDOUT : q.ECONNABORTED, r2, u2)), u2 = null;
            }, void 0 === o2 && s2.setContentType(null), "setRequestHeader" in u2 && I.forEach(s2.toJSON(), function(e4, t4) {
              u2.setRequestHeader(t4, e4);
            }), I.isUndefined(r2.withCredentials) || (u2.withCredentials = !!r2.withCredentials), a2 && "json" !== a2 && (u2.responseType = r2.responseType), "function" == typeof r2.onDownloadProgress && u2.addEventListener("progress", Oe(r2.onDownloadProgress, true)), "function" == typeof r2.onUploadProgress && u2.upload && u2.upload.addEventListener("progress", Oe(r2.onUploadProgress)), (r2.cancelToken || r2.signal) && (i2 = (t4) => {
              u2 && (n3(!t4 || t4.type ? new Se(null, e3, u2) : t4), u2.abort(), u2 = null);
            }, r2.cancelToken && r2.cancelToken.subscribe(i2), r2.signal && (r2.signal.aborted ? i2() : r2.signal.addEventListener("abort", i2)));
            const f2 = function(e4) {
              const t4 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e4);
              return t4 && t4[1] || "";
            }(r2.url);
            f2 && -1 === ue.protocols.indexOf(f2) ? n3(new q("Unsupported protocol " + f2 + ":", q.ERR_BAD_REQUEST, e3)) : u2.send(o2 || null);
          });
        }, Pe = (e3, t3) => {
          let n3, r2 = new AbortController();
          const o2 = function(e4) {
            if (!n3) {
              n3 = true, i2();
              const t4 = e4 instanceof Error ? e4 : this.reason;
              r2.abort(t4 instanceof q ? t4 : new Se(t4 instanceof Error ? t4.message : t4));
            }
          };
          let s2 = t3 && setTimeout(() => {
            o2(new q(`timeout ${t3} of ms exceeded`, q.ETIMEDOUT));
          }, t3);
          const i2 = () => {
            e3 && (s2 && clearTimeout(s2), s2 = null, e3.forEach((e4) => {
              e4 && (e4.removeEventListener ? e4.removeEventListener("abort", o2) : e4.unsubscribe(o2));
            }), e3 = null);
          };
          e3.forEach((e4) => e4 && e4.addEventListener && e4.addEventListener("abort", o2));
          const { signal: a2 } = r2;
          return a2.unsubscribe = i2, [a2, () => {
            s2 && clearTimeout(s2), s2 = null;
          }];
        };
        const Ne = function* (e3, t3) {
          let n3 = e3.byteLength;
          if (!t3 || n3 < t3) return void (yield e3);
          let r2, o2 = 0;
          for (; o2 < n3; ) r2 = o2 + t3, yield e3.slice(o2, r2), o2 = r2;
        }, _e = (e3, t3, n3, r2, o2) => {
          const s2 = async function* (e4, t4, n4) {
            for await (const r3 of e4) yield* Ne(ArrayBuffer.isView(r3) ? r3 : await n4(String(r3)), t4);
          }(e3, t3, o2);
          let i2 = 0;
          return new ReadableStream({ type: "bytes", async pull(e4) {
            const { done: t4, value: o3 } = await s2.next();
            if (t4) return e4.close(), void r2();
            let a2 = o3.byteLength;
            n3 && n3(i2 += a2), e4.enqueue(new Uint8Array(o3));
          }, cancel: (e4) => (r2(e4), s2.return()) }, { highWaterMark: 2 });
        }, Ue = (e3, t3) => {
          const n3 = null != e3;
          return (r2) => setTimeout(() => t3({ lengthComputable: n3, total: e3, loaded: r2 }));
        }, Fe = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response, Be = Fe && "function" == typeof ReadableStream, Me = Fe && ("function" == typeof TextEncoder ? (De = new TextEncoder(), (e3) => De.encode(e3)) : async (e3) => new Uint8Array(await new Response(e3).arrayBuffer()));
        var De;
        const He = Be && (() => {
          let e3 = false;
          const t3 = new Request(ue.origin, { body: new ReadableStream(), method: "POST", get duplex() {
            return e3 = true, "half";
          } }).headers.has("Content-Type");
          return e3 && !t3;
        })(), Ie = Be && !!(() => {
          try {
            return I.isReadableStream(new Response("").body);
          } catch (e3) {
          }
        })(), qe = { stream: Ie && ((e3) => e3.body) };
        var ze;
        Fe && (ze = new Response(), ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e3) => {
          !qe[e3] && (qe[e3] = I.isFunction(ze[e3]) ? (t3) => t3[e3]() : (t3, n3) => {
            throw new q(`Response type '${e3}' is not supported`, q.ERR_NOT_SUPPORT, n3);
          });
        }));
        const Je = { http: null, xhr: Le, fetch: Fe && (async (e3) => {
          let { url: t3, method: n3, data: r2, signal: o2, cancelToken: s2, timeout: i2, onDownloadProgress: a2, onUploadProgress: c2, responseType: u2, headers: l2, withCredentials: f2 = "same-origin", fetchOptions: h2 } = Ce(e3);
          u2 = u2 ? (u2 + "").toLowerCase() : "text";
          let p2, d2, [m2, y2] = o2 || s2 || i2 ? Pe([o2, s2], i2) : [];
          const g2 = () => {
            !p2 && setTimeout(() => {
              m2 && m2.unsubscribe();
            }), p2 = true;
          };
          let b2;
          try {
            if (c2 && He && "get" !== n3 && "head" !== n3 && 0 !== (b2 = await (async (e4, t4) => {
              const n4 = I.toFiniteNumber(e4.getContentLength());
              return null == n4 ? (async (e5) => null == e5 ? 0 : I.isBlob(e5) ? e5.size : I.isSpecCompliantForm(e5) ? (await new Request(e5).arrayBuffer()).byteLength : I.isArrayBufferView(e5) ? e5.byteLength : (I.isURLSearchParams(e5) && (e5 += ""), I.isString(e5) ? (await Me(e5)).byteLength : void 0))(t4) : n4;
            })(l2, r2))) {
              let e4, n4 = new Request(t3, { method: "POST", body: r2, duplex: "half" });
              I.isFormData(r2) && (e4 = n4.headers.get("content-type")) && l2.setContentType(e4), n4.body && (r2 = _e(n4.body, 65536, Ue(b2, Oe(c2)), null, Me));
            }
            I.isString(f2) || (f2 = f2 ? "cors" : "omit"), d2 = new Request(t3, { ...h2, signal: m2, method: n3.toUpperCase(), headers: l2.normalize().toJSON(), body: r2, duplex: "half", withCredentials: f2 });
            let o3 = await fetch(d2);
            const s3 = Ie && ("stream" === u2 || "response" === u2);
            if (Ie && (a2 || s3)) {
              const e4 = {};
              ["status", "statusText", "headers"].forEach((t5) => {
                e4[t5] = o3[t5];
              });
              const t4 = I.toFiniteNumber(o3.headers.get("content-length"));
              o3 = new Response(_e(o3.body, 65536, a2 && Ue(t4, Oe(a2, true)), s3 && g2, Me), e4);
            }
            u2 = u2 || "text";
            let i3 = await qe[I.findKey(qe, u2) || "text"](o3, e3);
            return !s3 && g2(), y2 && y2(), await new Promise((t4, n4) => {
              xe(t4, n4, { data: i3, headers: we.from(o3.headers), status: o3.status, statusText: o3.statusText, config: e3, request: d2 });
            });
          } catch (t4) {
            if (g2(), t4 && "TypeError" === t4.name && /fetch/i.test(t4.message)) throw Object.assign(new q("Network Error", q.ERR_NETWORK, e3, d2), { cause: t4.cause || t4 });
            throw q.from(t4, t4 && t4.code, e3, d2);
          }
        }) };
        I.forEach(Je, (e3, t3) => {
          if (e3) {
            try {
              Object.defineProperty(e3, "name", { value: t3 });
            } catch (e4) {
            }
            Object.defineProperty(e3, "adapterName", { value: t3 });
          }
        });
        const We = (e3) => `- ${e3}`, Ve = (e3) => I.isFunction(e3) || null === e3 || false === e3;
        var Ke = (e3) => {
          e3 = I.isArray(e3) ? e3 : [e3];
          const { length: t3 } = e3;
          let n3, r2;
          const o2 = {};
          for (let s2 = 0; s2 < t3; s2++) {
            let t4;
            if (n3 = e3[s2], r2 = n3, !Ve(n3) && (r2 = Je[(t4 = String(n3)).toLowerCase()], void 0 === r2)) throw new q(`Unknown adapter '${t4}'`);
            if (r2) break;
            o2[t4 || "#" + s2] = r2;
          }
          if (!r2) {
            const e4 = Object.entries(o2).map(([e5, t4]) => `adapter ${e5} ` + (false === t4 ? "is not supported by the environment" : "is not available in the build"));
            throw new q("There is no suitable adapter to dispatch the request " + (t3 ? e4.length > 1 ? "since :\n" + e4.map(We).join("\n") : " " + We(e4[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT");
          }
          return r2;
        };
        function Ge(e3) {
          if (e3.cancelToken && e3.cancelToken.throwIfRequested(), e3.signal && e3.signal.aborted) throw new Se(null, e3);
        }
        function $e(e3) {
          return Ge(e3), e3.headers = we.from(e3.headers), e3.data = ve.call(e3, e3.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e3.method) && e3.headers.setContentType("application/x-www-form-urlencoded", false), Ke(e3.adapter || he.adapter)(e3).then(function(t3) {
            return Ge(e3), t3.data = ve.call(e3, e3.transformResponse, t3), t3.headers = we.from(t3.headers), t3;
          }, function(t3) {
            return Ee(t3) || (Ge(e3), t3 && t3.response && (t3.response.data = ve.call(e3, e3.transformResponse, t3.response), t3.response.headers = we.from(t3.response.headers))), Promise.reject(t3);
          });
        }
        const Xe = {};
        ["object", "boolean", "number", "function", "string", "symbol"].forEach((e3, t3) => {
          Xe[e3] = function(n3) {
            return typeof n3 === e3 || "a" + (t3 < 1 ? "n " : " ") + e3;
          };
        });
        const Ye = {};
        Xe.transitional = function(e3, t3, n3) {
          function r2(e4, t4) {
            return "[Axios v1.7.2] Transitional option '" + e4 + "'" + t4 + (n3 ? ". " + n3 : "");
          }
          return (n4, o2, s2) => {
            if (false === e3) throw new q(r2(o2, " has been removed" + (t3 ? " in " + t3 : "")), q.ERR_DEPRECATED);
            return t3 && !Ye[o2] && (Ye[o2] = true, console.warn(r2(o2, " has been deprecated since v" + t3 + " and will be removed in the near future"))), !e3 || e3(n4, o2, s2);
          };
        };
        var Qe = { assertOptions: function(e3, t3, n3) {
          if ("object" != typeof e3) throw new q("options must be an object", q.ERR_BAD_OPTION_VALUE);
          const r2 = Object.keys(e3);
          let o2 = r2.length;
          for (; o2-- > 0; ) {
            const s2 = r2[o2], i2 = t3[s2];
            if (i2) {
              const t4 = e3[s2], n4 = void 0 === t4 || i2(t4, s2, e3);
              if (true !== n4) throw new q("option " + s2 + " must be " + n4, q.ERR_BAD_OPTION_VALUE);
            } else if (true !== n3) throw new q("Unknown option " + s2, q.ERR_BAD_OPTION);
          }
        }, validators: Xe };
        const Ze = Qe.validators;
        class et {
          constructor(e3) {
            this.defaults = e3, this.interceptors = { request: new te(), response: new te() };
          }
          async request(e3, t3) {
            try {
              return await this._request(e3, t3);
            } catch (e4) {
              if (e4 instanceof Error) {
                let t4;
                Error.captureStackTrace ? Error.captureStackTrace(t4 = {}) : t4 = new Error();
                const n3 = t4.stack ? t4.stack.replace(/^.+\n/, "") : "";
                try {
                  e4.stack ? n3 && !String(e4.stack).endsWith(n3.replace(/^.+\n.+\n/, "")) && (e4.stack += "\n" + n3) : e4.stack = n3;
                } catch (e5) {
                }
              }
              throw e4;
            }
          }
          _request(e3, t3) {
            "string" == typeof e3 ? (t3 = t3 || {}).url = e3 : t3 = e3 || {}, t3 = je(this.defaults, t3);
            const { transitional: n3, paramsSerializer: r2, headers: o2 } = t3;
            void 0 !== n3 && Qe.assertOptions(n3, { silentJSONParsing: Ze.transitional(Ze.boolean), forcedJSONParsing: Ze.transitional(Ze.boolean), clarifyTimeoutError: Ze.transitional(Ze.boolean) }, false), null != r2 && (I.isFunction(r2) ? t3.paramsSerializer = { serialize: r2 } : Qe.assertOptions(r2, { encode: Ze.function, serialize: Ze.function }, true)), t3.method = (t3.method || this.defaults.method || "get").toLowerCase();
            let s2 = o2 && I.merge(o2.common, o2[t3.method]);
            o2 && I.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e4) => {
              delete o2[e4];
            }), t3.headers = we.concat(s2, o2);
            const i2 = [];
            let a2 = true;
            this.interceptors.request.forEach(function(e4) {
              "function" == typeof e4.runWhen && false === e4.runWhen(t3) || (a2 = a2 && e4.synchronous, i2.unshift(e4.fulfilled, e4.rejected));
            });
            const c2 = [];
            let u2;
            this.interceptors.response.forEach(function(e4) {
              c2.push(e4.fulfilled, e4.rejected);
            });
            let l2, f2 = 0;
            if (!a2) {
              const e4 = [$e.bind(this), void 0];
              for (e4.unshift.apply(e4, i2), e4.push.apply(e4, c2), l2 = e4.length, u2 = Promise.resolve(t3); f2 < l2; ) u2 = u2.then(e4[f2++], e4[f2++]);
              return u2;
            }
            l2 = i2.length;
            let h2 = t3;
            for (f2 = 0; f2 < l2; ) {
              const e4 = i2[f2++], t4 = i2[f2++];
              try {
                h2 = e4(h2);
              } catch (e5) {
                t4.call(this, e5);
                break;
              }
            }
            try {
              u2 = $e.call(this, h2);
            } catch (e4) {
              return Promise.reject(e4);
            }
            for (f2 = 0, l2 = c2.length; f2 < l2; ) u2 = u2.then(c2[f2++], c2[f2++]);
            return u2;
          }
          getUri(e3) {
            return ee(Te((e3 = je(this.defaults, e3)).baseURL, e3.url), e3.params, e3.paramsSerializer);
          }
        }
        I.forEach(["delete", "get", "head", "options"], function(e3) {
          et.prototype[e3] = function(t3, n3) {
            return this.request(je(n3 || {}, { method: e3, url: t3, data: (n3 || {}).data }));
          };
        }), I.forEach(["post", "put", "patch"], function(e3) {
          function t3(t4) {
            return function(n3, r2, o2) {
              return this.request(je(o2 || {}, { method: e3, headers: t4 ? { "Content-Type": "multipart/form-data" } : {}, url: n3, data: r2 }));
            };
          }
          et.prototype[e3] = t3(), et.prototype[e3 + "Form"] = t3(true);
        });
        var tt = et;
        class nt {
          constructor(e3) {
            if ("function" != typeof e3) throw new TypeError("executor must be a function.");
            let t3;
            this.promise = new Promise(function(e4) {
              t3 = e4;
            });
            const n3 = this;
            this.promise.then((e4) => {
              if (!n3._listeners) return;
              let t4 = n3._listeners.length;
              for (; t4-- > 0; ) n3._listeners[t4](e4);
              n3._listeners = null;
            }), this.promise.then = (e4) => {
              let t4;
              const r2 = new Promise((e5) => {
                n3.subscribe(e5), t4 = e5;
              }).then(e4);
              return r2.cancel = function() {
                n3.unsubscribe(t4);
              }, r2;
            }, e3(function(e4, r2, o2) {
              n3.reason || (n3.reason = new Se(e4, r2, o2), t3(n3.reason));
            });
          }
          throwIfRequested() {
            if (this.reason) throw this.reason;
          }
          subscribe(e3) {
            this.reason ? e3(this.reason) : this._listeners ? this._listeners.push(e3) : this._listeners = [e3];
          }
          unsubscribe(e3) {
            if (!this._listeners) return;
            const t3 = this._listeners.indexOf(e3);
            -1 !== t3 && this._listeners.splice(t3, 1);
          }
          static source() {
            let e3;
            return { token: new nt(function(t3) {
              e3 = t3;
            }), cancel: e3 };
          }
        }
        var rt = nt;
        const ot = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 };
        Object.entries(ot).forEach(([e3, t3]) => {
          ot[t3] = e3;
        });
        var st = ot;
        const it = function e3(t3) {
          const n3 = new tt(t3), o2 = r(tt.prototype.request, n3);
          return I.extend(o2, tt.prototype, n3, { allOwnKeys: true }), I.extend(o2, n3, null, { allOwnKeys: true }), o2.create = function(n4) {
            return e3(je(t3, n4));
          }, o2;
        }(he);
        it.Axios = tt, it.CanceledError = Se, it.CancelToken = rt, it.isCancel = Ee, it.VERSION = "1.7.2", it.toFormData = $, it.AxiosError = q, it.Cancel = it.CanceledError, it.all = function(e3) {
          return Promise.all(e3);
        }, it.spread = function(e3) {
          return function(t3) {
            return e3.apply(null, t3);
          };
        }, it.isAxiosError = function(e3) {
          return I.isObject(e3) && true === e3.isAxiosError;
        }, it.mergeConfig = je, it.AxiosHeaders = we, it.formToJSON = (e3) => le(I.isHTMLForm(e3) ? new FormData(e3) : e3), it.getAdapter = Ke, it.HttpStatusCode = st, it.default = it, e2.exports = it;
      } }, t = {};
      function n(r) {
        var o = t[r];
        if (void 0 !== o) return o.exports;
        var s = t[r] = { exports: {} };
        return e[r](s, s.exports, n), s.exports;
      }
      return n.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
          return this || new Function("return this")();
        } catch (e2) {
          if ("object" == typeof window) return window;
        }
      }(), n(425);
    })());
  }
});
export default require_upload();
/*! Bundled license information:

enlarge-file-upload/dist/upload.js:
  (*! For license information please see upload.js.LICENSE.txt *)
*/
//# sourceMappingURL=enlarge-file-upload.js.map
